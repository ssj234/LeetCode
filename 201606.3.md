###Roman to Integer
Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
给定一个罗马数字，将其转为整数。
罗马数字：
罗马数字共有七个，即I(1)，V(5)，X(10)，L(50)，C(100)，D(500)，M(1000)。
1. 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3；
2. 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12；
3. 小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9；当符号 I、X 或 C 位于大数的后面时就作为加数；位于大数的前面就作为减数。
4. 在一个数的上面画一条横线，表示这个数增值 1,000 倍，

Ⅲ=3、Ⅳ=4、Ⅵ=6、XIX=19、XX=20、XLV=45、MCMLXXX=1980。

```
//由于需要将字符与数字对应并具有优先级，先存储这些
//MDCCCLXXXVIII, 1888 
//MDCCCXCIX, 1899 
//[19ms,198.87%]
 public int romanToInt(String s) {
        Map<Character,Integer> map=initMap();
        int sum=0,len=s.length(),i=1;
        while(i<len){
            char prev=s.charAt(i-1);
            int a=map.get(prev);
            int b=map.get(s.charAt(i));
            if((prev=='I'||prev=='X'||prev=='C')&&a<b){//当符号 I、X 或 C 位于大数的后面时就作为加数；位于大数的前面就作为减数。
                sum-=a;
            }else{
                sum+=a;
            }
            i++;
        }
        sum+=map.get(s.charAt(len-1));
        return sum;
    }
    //构造map，存储优先级和对应的整数
     public Map<Character,Integer>  initMap(){
    	Map<Character,Integer>  map=new HashMap<Character, Integer>();
    	map.put('I', 1);
    	map.put('V', 5);
    	map.put('X', 10);
    	map.put('L', 50);
    	map.put('C', 100);
    	map.put('D', 500);
    	map.put('M', 1000);
    	return map;
    }
```

优化，对于类型不大且固定的整数/字母来说，无需构造map真心慢啊，使用数组就可以了。
```
//[7ms,81%]
public int romanToInt(String s) {
        int map[]=new int[26];
        map['I' - 'A'] = 1;
        map['V' - 'A'] = 5;
        map['X' - 'A'] = 10;
        map['L' - 'A'] = 50;
        map['C' - 'A'] = 100;
        map['D' - 'A'] = 500;
        map['M' - 'A'] = 1000;
        int sum=0,len=s.length(),i=1;
        while(i<len){
            char prev=s.charAt(i-1);
            int a=map[prev-'A'];
            int b=map[s.charAt(i)-'A'];
            if((prev=='I'||prev=='X'||prev=='C')&&a<b){//当符号 I、X 或 C 位于大数的后面时就作为加数；位于大数的前面就作为减数。
                sum-=a;
            }else{
                sum+=a;
            }
            i++;
        }
        sum+=map[s.charAt(len-1)-'A'];
        return sum;
    }
    
```


###Lowest Common Ancestor of a Binary Search Tree
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself
给定一个二叉查找树，找出给定两个节点具有的最近的祖先。
