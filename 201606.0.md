###Intersection of Two Arrays
Given two arrays, write a function to compute their intersection.
Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].
给定两个数组，计算重复的数字

```
//最笨的方法，循环两次，复杂度为：O(M*N) 花费时间：19 ms，击败8.94%
public int[] intersection(int[] nums1, int[] nums2) {
        
		int len1=nums1.length;
		int len2=nums2.length;
		boolean flag;
		if(len1==0||len2==0){
			return new int[]{};
		}
		ArrayList<Integer> ret=new ArrayList<Integer>(10);
		for(int i=0;i<len1;i++){//遍历数组1
			int a1=nums1[i];
			for(int j=0;j<len2;j++){//遍历数组2
				int a2=nums2[j];
				if(a1==a2){
					flag=false;
					for(int y=0;y<ret.size();y++){//是否已经存在
						if(ret.get(y)==a1){
							flag=true;
							break;
						}
					}
					if(!flag){
						ret.add(a1);
					}
					
				}
			}
		}
		
		int rs[]=new int[ret.size()];
		for(int u=0;u<ret.size();u++){
			rs[u]=ret.get(u);
		}
		return rs;
	
    }
```
```
//采用先排序，后归并的方式，复杂度为：O(MlogM+NlogN+M+N) M=N时为O(NlogN)花费时间：3 ms，击败98.72%
public class Solution {
   public int[] intersection(int[] nums1, int[] nums2) {
		quickSort(nums1, 0, nums1.length-1);//排序
		quickSort(nums2, 0, nums2.length-1);//排序
		int i=0,j=0,tmp,index=0;
		int ret[]=new int[1024];
		while(i<nums1.length&&j<nums2.length){
			if(nums1[i]<nums2[j]){
				i++;
			}else if(nums1[i]>nums2[j]){
				j++;
			}else{
				tmp=nums1[i++];j++;
				ret[index++]=tmp;
				for(;i<nums1.length;){
					if(nums1[i]==tmp){
						i++;
					}else{
						break;
					}
				}
				for(;j<nums2.length;){
					if(nums2[j]==tmp){
						j++;
					}else{
						break;
					}
				}
			}
		}
		int rs[]=new int[index];
		for(i=0;i<index;i++){
			rs[i]=ret[i];
		}
		return rs;
	}

	//快速排序
	public void quickSort(int[] a,int begin,int end){
		if(begin>=end||begin<0||end<0){
			return;
		}
		int mid=begin+(end-begin)/2,i=begin,j=end,tmp=a[mid];
		swap(a, end, mid);//交换
		
		while(i<j){
			for(;i<j&&a[i]<tmp;i++){}
			for(;i<j&&a[j]>tmp;j--){}
			
			//i==j或
			if(a[i]==a[j]){//若与tmp均相等了，就不会前进了，
				i++;
			}else{
				swap(a, i, j);
			}
		}
		quickSort(a, begin, j-1);
		quickSort(a, j+1, end);
	}
	private void swap(int a[],int i,int j){
		int tmp=a[i];
		a[i]=a[j];
		a[j]=tmp;
	}
    
}
```

```
//使用hash的方法，应该为O(M+N) 但是实际速度9ms 击败18.70%
public int[] intersection(int[] nums1, int[] nums2) {
       
		int size=0,index=0;
		Map map=new HashMap(128);
		for(int i=0;i<nums1.length;i++){
			map.put(nums1[i],1);
		}
		for(int i=0;i<nums2.length;i++){
			int cnt=0;
			Object obj=map.get(nums2[i]);
			if(obj!=null){
				cnt=(Integer)obj;
				if(cnt==1)size++;
				map.put(nums2[i],cnt+1);
			}else{
				map.put(nums2[i],null);
			}
			
			
		}
		
		int ret[]=new int[size];
		if(size==0)return ret;
		Iterator it=map.keySet().iterator();
		while(it.hasNext()){
			int key=(Integer) it.next();
			Object obj=map.get(key);
			if(obj==null)continue;
			int value=(Integer) obj;
			
			if(value>1){
				ret[index++]=key;
			}
		}
		return ret;
	
	}
```

###Submission Details
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]
给定一个数组，编写一个方法，将所有的0移动数组的最后，并且保持非0数字的相对位置。例如[0, 1, 0, 3, 12]转为[1, 3, 12, 0, 0]
```
public void moveZeroes(int[] nums) {
		int cnt=0;
		for(int i=0;i<nums.length;i++){
			if(nums[i]!=0){
				nums[cnt++]=nums[i];
			}
		}
		for(;cnt<nums.length;cnt++){
			nums[cnt]=0;
		}
    }
```
